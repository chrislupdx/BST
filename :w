//Chris Lu
//Project 4
//Table.cpp
//This is the implemtation of the .cpp for the table.cpp

#include "tree.h"
using namespace std;

tree::tree()
{
    root = NULL; 
}

tree::~tree()
{
    this->removeAll();
}

//this is a wrapper function?? (plualizes it?)
int tree::removeArtist(char * key)
{
    if(!root) return 0;
    bool LR;
    removeArtist(root, key, LR);
    return 1;
}

//a single removal
int tree::removeArtist(tNode *& root, char * key, bool LR)
{
    if(!root)
    {
        return 0;
    }
    if(strcmp(root->songData->artist, key) == 0 )
    {
        if(!root->left && !root->right) //a leaf
        {
            delete root;
            root = NULL;
        }
        else if(LR) //if we came from the left
        {
            if(!root->right && root->left) //1 child (if we do not have a right)
            {
                tNode * hold;
                hold = root->left;
                delete root;
                root = hold;
            }
            else if(root->right) //comibning the right and left child into 1ish caseish
            {
                tNode * ios = NULL; 
                tNode * ios_parent = NULL; //the parent OR ITSELF
                iosParent(root , ios_parent);
                if(!ios_parent->left) //if there isn't a left
                {
                    ios = ios_parent;
                }
                else 
                {
                    ios = ios_parent->left;
                }
                //deletion happens ehre 
                ios->left = root->left;
                ios->right = root->right;
                delete root; 
                root = ios;
                ios_parent->left = NULL; //if we assign null to null 
            }
        }
        else //the right subtree
        {
            if(root->right && !root->left) //right child no left
            {
                tNode * hold;
                hold = root->right;
                delete root;
                root = hold;

            }
            else if(root->left) //if there is a left
            {
                //if we have a tree w/ left child
                //L child = new replaceme
                //hold right R child
                //this section is not done
                tNode * ios = NULL; 
                tNode * ios_parent = NULL; //the parent OR ITSELF
                iosParent(root , ios_parent);
                if(!ios_parent->right) //if there isn't a right
                {
                    ios = ios_parent;
                }
                else 
                {
                    ios = ios_parent->right;
                }

                //deletion happens ehre needs to be moddded for right
                ios->right = root->right;
                ios->left = root->left;
                delete root; 
                root = ios;
                ios_parent->right = NULL; //if we assign null to null 
            }
        }

    }
    //right child no left is going to be painful

    //  else                //2 children
    // {
    //if the right child has no left
    //else go through the 
    // }
}

int tree::removeArtist(tNode root, key, true); //passing bool as a true bc true==left

return removeArtist(root->right, key, false);
}


//recursive call, returns the # of nodes
int tree::removeAll(tNode *& root)
{
    if(!root) return 0;

    int val = removeAll(root->left) + removeAll(root->right);  //after the traversal

    delete root;
    root = NULL; 

    return val;
}

//In order successor should be the smallest item in the right subtree
int tree::ios(tNode * tree, tNode *& returnVal)
{
    if(!tree) return 0;
    if(!tree->left) //when we have reached the smallest
    {
        returnVal = tree->left;
    }
    ios(tree->left, returnVal);

    return 1; 
}

//get leftmost thing in right subtree
//In order successor should be the smallest item in the right subtree 
int tree::iosParent(tNode * tree, tNode *& returnVal)
{
    if(!tree) return 0;
    if(tree->left && !tree->left->left) //the parent of iOS
    {
        returnVal = tree;
        return 1;
    }
    if(!tree->left) //if there is no left, we are the left
    {
        returnVal = tree;
        return 1;
    }
    ios(tree->left, returnVal);
    return 1;
}

//This wrapper does nothing but shield the outside from recursion
int tree::removeAll()
{
    if(!root) return 0;
    removeAll(root);
    return 1;
}

//recursive insert
int tree::insert(song & song_toadd)
{
    insert(root, song_toadd);

    return 1;
}

//we're inserting songs, and keying them by song title
int tree::insert(tNode *& root, song & song_toadd) 
{
    if(!root)
    {
        root = new tNode(song_toadd); //implicitly hooks root's right pointer to this one
        return 1;
    }
    //check if < 0 is greater than or smller than?
    else if(strcmp(root->songData->artist, song_toadd.artist) < 0) 
    {
        return insert(root->right, song_toadd);  //**!
    }
    else
    {
        return insert(root->left, song_toadd);
    } 
}

int tree::displayAll()
{
    std::cout << "displayall" << std::endl;
    displayAll(root);
    std::cout << "done" << std::endl;
    return 1;
}


//having some troubl with bigger vals:q
//
int tree::displayAll(tNode *& root)  
{
    if(!root) return 0;

    int count = displayAll(root->left) + 1;
    root->songData->displayInfo();

    return count + displayAll(root->right);
}

int tree::retrieveByKey(char * key_tosearch, song & foundval )
{
    return retrieveByKey(root, key_tosearch, foundval);
}

//this retrieves only the first
int tree::retrieveByKey(tNode * root, char * key_tosearch, song & foundval)
{
    if(!root) return 0;

    int isMatching = strcmp(root->songData->artist, key_tosearch);
    if(isMatching == 0) //if we find a match, append it and keep searching?
    {
        foundval.copySong(*root->songData); //not sure if doneA
        return 1;
    }
    else if(isMatching > 0)
    {
        return retrieveByKey(root->left, key_tosearch, foundval);
    }
    else
    {
        return retrieveByKey(root->right, key_tosearch, foundval);
    }
}

//BELOW IS A MOD FOR TREE INSERT INSTEAD OF SONG
int tree::retrieveByKeyAll(char * key_tosearch, tree & foundSongs )
{
    return retrieveByKeyAll(root, key_tosearch, foundSongs);
}

//BELOW IS A UNIFINISEHD MOD FOR TREE INSERT INSTEAD OF SONG
int tree::retrieveByKeyAll(tNode * root, char * key_tosearch, tree & foundSongs)
{
    if(!root) return 0;

    int isMatching = strcmp(root->songData->artist, key_tosearch);
    if(isMatching == 0) //if we find a match, append it and keep searching?
    {
        //foundval.copySong(*root->songData); //not sure if doneA
        return 1;
    }
    else if(isMatching > 0)
    {
        return retrieveByKeyAll(root->left, key_tosearch, foundSongs);
    }
    else
    {
        return retrieveByKeyAll(root->right, key_tosearch, foundSongs);
    }
}

//write a retriveallmatches 
//how do we do it return an array of values
int tree::displayByKey(char * key_tosearch)
{
    displayByKey(root, key_tosearch); 
    return 1;    
}

//recursive
int tree::displayByKey(tNode * root, char * searchKey)
{
    if(!root) return 0; //if leaf

    int count = displayByKey(root->left, searchKey);
    int isMatching = strcmp(root->songData->artist, searchKey);
    if(isMatching == 0)
    {
        root->songData->displayInfo();
    }
    return count + displayByKey(root->right, searchKey);
}

//pull stuff into songs
int tree::readFile(song **&songs,int size)
{
    int SIZE = 100; //line item is n number of chars
    int DESCSIZE = 900;
    ifstream inFile;

    inFile.open("musicshort.txt");

    if(inFile)
    {
        int count = 0;
        char eof = inFile.peek();
        while((!inFile.eof()) && (eof != -1) && (count < size))
        {
            char tempfile[100];
            inFile.get(tempfile, SIZE, '|');
            inFile.ignore(10, '|');

            char temptitle[100];
            inFile.get(temptitle, SIZE, '|');
            inFile.ignore(10, '|');

            char tempAlbum[100];
            inFile.get(tempAlbum, SIZE, '|');
            inFile.ignore(10, '|');

            char tempKey1[100];
            inFile.get(tempKey1, SIZE, '|');
            inFile.ignore(10, '|');

            char tempKey2[100];
            inFile.get(tempKey2, SIZE, '|');
            inFile.ignore(10, '|');

            char tempKey3[100];
            inFile.get(tempKey3, SIZE, '|');
            inFile.ignore(10, '|');

            char tempDesc[400];
            inFile.get(tempDesc, DESCSIZE, '\n'); inFile.ignore(10, '\n');

            song newsong(tempfile, temptitle, tempAlbum, tempKey1, tempKey2, tempKey3, tempDesc); //temptitle==song name, tempfile==artist
            insert(newsong);  //we are using the artist name as key in the BST

            eof = inFile.peek();
            count++;
        }
    }
    inFile.close();
    inFile.clear();
    return 1;
}
